# Candidate Components for Reuse

This table lists potential Agent Zero components that could be reused in Billy v2.  Each entry summarises what the component does, why it may be valuable, how it might be integrated, and any associated risks.

| Component | Repo | Location | What it does | Reuse value | Integration approach | Risks |
| --- | --- | --- | --- | --- | --- | --- |
| **Tool registry & loader** | Agent Zero | `python/helpers/extract_tools.py`, `python/tools/` | Discovers and imports tool classes from the `python/tools` folder; each tool defines its own argument schema, description and execution method.  Works in concert with prompt templates to expose tool metadata to the agent. | High.  Billy currently has no concept of tools.  Reusing Agent Zero’s dynamic discovery pattern provides an immediate way to register and describe tools. | **Adapter**: build a `ToolRegistry` interface in Billy.  Use Agent Zero’s loader to import tool classes, translate their schema to Billy’s format and provide stubs for execution. | Agent Zero’s tools assume certain prompt structures and context.  Coupling Billy too tightly could make upgrading difficult.  Need to ensure only the metadata is reused; execution remains in Billy’s control. |
| **Tool execution & sandboxing** | Agent Zero | `python/helpers/docker.py`, `python/helpers/process.py`, `python/tools/code_execution_tool.py` | Provides functions to run code in a sandboxed Python/Node.js/shell environment and, via Docker helpers, to build and run container images with resource limits. | Medium‑High.  Billy will need a secure execution substrate (Phase 3) for tools.  Agent Zero’s Docker helper can inform the design. | **Re‑implement / Vendor small pieces**: Use Agent Zero as inspiration for designing `DockerRunner` in Billy.  Vendor small helper functions if they are self‑contained. | Agent Zero’s Docker logic is designed for its own runtime container; differences in context may limit direct reuse. |
| **Vector‑store memory** | Agent Zero | `python/helpers/memory.py`, `python/helpers/memory_consolidation.py` | Implements memory storage using FAISS and LangChain embeddings.  Supports writing, querying, and summarising memory fragments. | High.  Billy’s current memory is a simple key/value store.  A vector memory would allow retrieval of relevant past interactions and knowledge. | **Adapter or Vendor**: Wrap Agent Zero’s memory API behind a `MemoryStore` interface in Billy.  Optionally vendor parts of the FAISS wrapper if direct import becomes unwieldy. | Heavy dependencies (FAISS, LangChain).  Complexity of asynchronous API.  Must ensure memory data is kept separate per persona to avoid cross‑contamination. |
| **Logging & tracing framework** | Agent Zero | `python/helpers/log.py`, `python/helpers/print_style.py` | Provides structured logs and trace events for each agent step, including tool invocation, LLM calls and memory operations.  Logs are saved as HTML and can be inspected via UI. | Medium.  Adding structured events will make Billy debuggable and pave the way for a step inspector. | **Adapter or Re‑implement**: Define a `TraceSink` interface in Billy and map Agent Zero log events to this format.  Alternatively, re‑implement only the parts needed (e.g., event schema and emitter). | Agent Zero’s logger is tied to its agent context and UI.  We need to decouple without pulling in UI dependencies. |
| **Planner / agent loop** | Agent Zero | `agent.py`, `python/extensions/` | Implements an asynchronous loop that interleaves LLM calls, reasoning, tool selection, tool execution and memory operations.  Supports streaming and subordinate agents. | Medium.  Billy lacks an agent loop; adopting Agent Zero’s full loop could accelerate development. | **Adapter (optional)**: Use Agent Zero’s planner as a “strategy” module invoked as a tool within Billy’s own agent loop.  Do not replace Billy’s loop wholesale; treat it as an optional planning component. | Tight coupling with Agent Zero prompts and tools; risk of major rewriting if imported directly.  Start with limited experiments. |
| **Prompt & extension system** | Agent Zero | `prompts/`, `python/extensions/` | Rich set of prompt templates and extension hooks for customizing agent behaviour. | Low‑Medium.  Billy has its own charter system; however, some of Agent Zero’s templates (e.g., tool descriptions) may serve as examples. | **Re‑implement**: Use Agent Zero’s prompts as inspiration when designing Billy’s tool prompts and system messages. | Prompts are highly specific to Agent Zero’s design; copying them verbatim may conflict with Billy’s charter and persona. |

**Notes:**

- The integration approach column uses the categories defined in the comparison document: **adapter**, **vendor**, **dependency** or **re‑implement**.  In general, adapters minimise coupling by translating between Billy’s interfaces and Agent Zero’s implementations.  Vendoring involves copying a small, stable module into Billy’s codebase.  Direct dependency means Billy imports Agent Zero modules as a third‑party package.  Re‑implement means Billy writes its own version based on Agent Zero’s design patterns.
- Components not listed here (e.g., the Web UI or multi‑agent orchestration) are considered out of scope for the initial phases.